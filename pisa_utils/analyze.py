import json
import logging
import os
from time import time
from gemmi import cif

from pisa_utils.dictionaries import get_assembly_dict, get_bond_dict, get_molecules_dict
from pisa_utils.utils import parse_xml_file

logger = logging.getLogger()


class AnalysePisa:
    def __init__(self, pdb_id, assembly_id, xmls_dir, input_updated_cif, output_json):
        """
        Parses XML files generated by pisa lite, and serializing to JSON format.

        Also adds UniProt numbering using updated mmCIF file if provided.

        Args:
            pdb_id (str): PDB ID.
            assembly_id (str): Assembly ID.
            xmls_dir (str): directory containing XML files from PISA.
            input_updated_cif (str): Path to updated mmCIF file with Uniprot Mapping.
            output_json (str): Path to output JSON files.

        """
        self.pdb_id = pdb_id
        self.assembly_code = assembly_id
        self.input_updated_cif = input_updated_cif
        self.output_json = output_json if output_json else None
        self.xmls_dir = xmls_dir
        self.results = {}

    def create_assem_interfaces_dict(self):
        """
        Function writes assembly interfaces dictionaries

        :return: type dict - assembly interfaces dictionary
        """

        start = time()

        logging.debug("creating assembly dictionary")

        interfaces_xml_file = os.path.join(self.xmls_dir, "interfaces.xml")
        assembly_xml_file = os.path.join(self.xmls_dir, "assembly.xml")
        result = {}
        interfaces_results = {}

        if os.path.exists(interfaces_xml_file) and os.path.exists(assembly_xml_file):
            asroot = parse_xml_file(xml_file=assembly_xml_file)
            root = parse_xml_file(xml_file=interfaces_xml_file)

            if (root is not None) and (asroot is not None):

                try:

                    assemblies = asroot.iter("asu_complex")

                    assem_result = get_assembly_dict(assemblies)

                except Exception:
                    logging.error(
                        "Invalid assembly dictionary: probably fields not found in xml file",
                        exc_info=True,
                    )

                # Create interfaces dictionaries

                status = root.find("status").text
                num_interfaces = root.find("n_interfaces").text

                logging.debug("Number of interfaces: {}".format(num_interfaces))

                result["status"] = status
                result["num_interfaces"] = num_interfaces

                non_ligand_interface_count = 0

                interfaces = root.iter("interface")

                # updated cif file path                                                                                                
                # path = os.path.join(input_updated_cif, "{}_updated.cif".format(pdb_id))
                updated_cif_path = self.input_updated_cif

                #parsing updated cif file 
                if (self.input_updated_cif and os.path.exists(self.input_updated_cif)):
                     doc = cif.read(updated_cif_path)
                     updated_cif_block = doc.sole_block()
                else:
                    logging.info(f"Updated CIF [{self.input_updated_cif}] is not provided or is invalid")
                    updated_cif_block = None

                
                for interface in interfaces:

                    # Interface General information
                    interface_id = interface.find("id").text
                    interface_area = round(float(interface.find("int_area").text), 2)
                    interface_solvation_energy = round(
                        float(interface.find("int_solv_en").text), 2
                    )
                    interface_stabilization_energy = round(
                        float(interface.find("stab_en").text), 2
                    )
                    p_value = round(float(interface.find("pvalue").text), 3)

                    # No. of bonds counted

                    n_h_bonds = int(interface.find("h-bonds/n_bonds").text)
                    n_ss_bonds = int(interface.find("ss-bonds/n_bonds").text)
                    n_covalent_bonds = int(interface.find("cov-bonds/n_bonds").text)
                    n_salt_bridges = int(interface.find("salt-bridges/n_bonds").text)
                    other_contacts = int(interface.find("other-bonds/n_bonds").text)

                    molecules = interface.iter("molecule")
                    (
                        molecules_dicts,
                        interface_residues_count,
                        is_invalid,
                    ) = get_molecules_dict(molecules)
                    
                    if (n_h_bonds==0 and n_ss_bonds==0 and n_covalent_bonds==0 and
                        n_salt_bridges==0 and other_contacts == 0 ):

                        is_invalid = True
                    
                    if not is_invalid:
                        non_ligand_interface_count += 1

                        # Reading bonds

                        hbonds = interface.find("h-bonds")
                        sbridges = interface.find("salt-bridges")
                        covbonds = interface.find("cov-bonds")
                        ssbonds = interface.find("ss-bonds")
                        othbonds = interface.find("other-bonds")

                        # Writing bonds dictionaries

                        # for hbond in hbonds:
                        hbond_dict = get_bond_dict(
                            hbonds, "H-bond", self.pdb_id,
                            updated_cif_block
                        )

                        # for sbridge in sbridges:
                        sbridge_dict = get_bond_dict(
                            sbridges,
                            "salt-bridges",
                            self.pdb_id,
                            updated_cif_block
                        )
                        # for covbond in covbonds:
                        covbond_dict = get_bond_dict(
                            covbonds,
                            "cov-bonds",
                            self.pdb_id,
                            updated_cif_block
                        )
                        # for ssbond in ssbonds:
                        ssbond_dict = get_bond_dict(
                            ssbonds, "ss-bonds", self.pdb_id, 
                            updated_cif_block
                        )
                        # for othbond in othbonds:
                        othbond_dict = get_bond_dict(
                            othbonds,
                            "other-bond",
                            self.pdb_id,
                            updated_cif_block
                        )

                        interface_dict = {
                            "interface_id": interface_id,
                            "interface_area": interface_area,
                            "solvation_energy": interface_solvation_energy,
                            "stabilization_energy": interface_stabilization_energy,
                            "p_value": p_value,
                            "number_interface_residues": interface_residues_count,
                            "number_hydrogen_bonds": n_h_bonds,
                            "number_covalent_bonds": n_covalent_bonds,
                            "number_disulfide_bonds": n_ss_bonds,
                            "number_salt_bridges": n_salt_bridges,
                            "number_other_bonds": other_contacts,
                            "hydrogen_bonds": hbond_dict,
                            "salt_bridges": sbridge_dict,
                            "disulfide_bonds": ssbond_dict,
                            "covalent_bonds": covbond_dict,
                            "other_bonds": othbond_dict,
                            "molecules": molecules_dicts,
                        }

                        # Append all dictionaries in 'result'

                        result.setdefault("id", []).append(interface_id)
                        result.setdefault("int_area", []).append(interface_area)
                        result.setdefault("interface_dicts", []).append(interface_dict)

                result["non_ligand_interface_count"] = non_ligand_interface_count

        if result and assem_result:

            overall = len(result.get("id", []))
            interface_dicts = result.get("interface_dicts", [])
            assem_dict = {
                "mmsize": assem_result.get("assembly_mmsize"),
                "dissociation_energy": assem_result.get("assembly_diss_energy"),
                "accessible_surface_area": assem_result.get("assembly_asa"),
                "buried_surface_area": assem_result.get("assembly_bsa"),
                "entropy": assem_result.get("assembly_entropy"),
                "dissociation_area": assem_result.get("assembly_diss_area"),
                "solvation_energy_gain": assem_result.get("assembly_int_energy"),
                "formula": assem_result.get("assembly_formula"),
                "composition": assem_result.get("assembly_composition"),
                "interface_count": overall,
                "interfaces": interface_dicts,
            }

            assembly_dictionary = {
                "pdb_id": self.pdb_id,
                "assembly_id": self.assembly_code,
                "pisa_version": "2.0",
                "assembly": assem_dict,
            }

            self.results.setdefault("PISA", assembly_dictionary)

            interfaces_results = self.results

        logging.info(
            f"Finished creating assembly-interfaces dictionary in {time() - start} seconds"
        )

        # dump to json file
        output_json = os.path.join(
            self.output_json,
            "{}-assembly{}-interfaces.json".format(self.pdb_id, self.assembly_code),
        )

        self._save_to_json(interfaces_results, output_json)

        return interfaces_results

    def create_assembly_dict(self):

        """Function writes simplified assembly dictionary

        :return: type dict - assembly dictionary
        """
        result = {}
        start = time()

        logging.debug("creating simplified assembly dictionary")

        assembly_xml_file = os.path.join(self.xmls_dir, "assembly.xml")
        result = {}

        if os.path.exists(assembly_xml_file):
            asroot = parse_xml_file(xml_file=assembly_xml_file)

        if asroot:

            try:
                assemblies = asroot.iter("asu_complex")

                assem_result = get_assembly_dict(assemblies)

            except Exception as e:
                logging.error(
                    "invalid assembly dictionary : probably fields not found in xml file"
                )
                logging.error(e)

            assem_dict = {
                "id": assem_result.get("assembly_id"),
                "size": assem_result.get("assembly_size"),
                "score": assem_result.get("assembly_score"),
                "macromolecular_size": assem_result.get("assembly_mmsize"),
                "dissociation_energy": assem_result.get("assembly_diss_energy"),
                "accessible_surface_area": assem_result.get("assembly_asa"),
                "buried_surface_area": assem_result.get("assembly_bsa"),
                "entropy": assem_result.get("assembly_entropy"),
                "dissociation_area": assem_result.get("assembly_diss_area"),
                "solvation_energy_gain": assem_result.get("assembly_int_energy"),
                "number_of_uc": assem_result.get("assembly_n_uc"),
                "number_of_dissociated_elements": assem_result.get("assembly_n_diss"),
                "symmetry_number": assem_result.get("assembly_sym_num"),
                "formula": assem_result.get("assembly_formula"),
                "composition": assem_result.get("assembly_composition"),
                "R350": assem_result.get("assembly_R350"),
            }

            assembly_dictionary = {
                "pdb_id": self.pdb_id,
                "assembly_id": self.assembly_code,
                "pisa_version": "2.0",
                "assembly": assem_dict,
            }

            result.setdefault("PISA", assembly_dictionary)

        logging.debug(
            f"Finished creating assembly simplified dictionary in {time() - start} seconds"
        )

        output_json = os.path.join(
            self.output_json,
            f"{self.pdb_id}-assembly{self.assembly_code}.json",
        )

        self._save_to_json(result, output_json)

        return result

    def _save_to_json(self, data, output_file):
        """Dump the data into a JSON file.

        Args:
            data (dict): The data to be dumped.
            output_file (str): The path to the output file.
        Raises:
            ValueError: If `data` is empty.
        """

        if data:
            with open(output_file, "w") as f:
                json.dump(data, f)
                logging.info(f"Data saved into {output_file} successful")

        else:
            raise ValueError("No data to save")
